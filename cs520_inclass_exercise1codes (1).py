# -*- coding: utf-8 -*-
"""cs520_inclass.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/13Dk0gUjLDzfmFCSDHE2PJ5Xk8GVqqBwl

## 1. Write a function to check if a string is a palindrome.
"""

#GPT-5/ CoT
def is_palindrome(s: str) -> bool:
    # Normalize: lowercase and remove all non-alphanumeric characters
    normalized = ''.join(ch.lower() for ch in s if ch.isalnum())
    # Compare with its reverse
    return normalized == normalized[::-1]

# Sonnet 4.5 / CoT
def is_palindrome_2(s: str) -> bool:
    # Normalize: remove spaces and punctuation, lowercase
    import re
    cleaned = re.sub(r'[^A-Za-z0-9]', '', s).lower()
    return cleaned == cleaned[::-1]

#GPT-5 / Self-Debugging


#Tests

print(is_palindrome("hello"))
print(is_palindrome("A man a plan a canal Panama"))

# Sonnet 4.5 / Self Debugging
def is_palindrome(s: str) -> bool:
    cleaned = s.replace(" ", "").lower()
    return cleaned == cleaned[::-1]

"""##2. Determine if a given integer is prime.

COT PROMPT USED:

"You are an expert Python programmer. Think step by step and explain your reasoning.
Write a Python function `is_prime(n: int) -> bool` that returns True if n is a prime
number and False otherwise.
"
"""

# GPT-5 / CoT
import math
def is_prime(n: int) -> bool:
    if n <= 1:
        return False
    if n <= 3:
        return True
    if n % 2 == 0 or n % 3 == 0:
        return False
    limit = int(math.sqrt(n)) + 1
    for i in range(5, limit, 2):
        if n % i == 0:
            return False
    return True

# Sonnet 4.5 / CoT
def is_prime_2(n: int) -> bool:
    """Return True if n is a prime number, False otherwise."""

    # Handle invalid types
    if not isinstance(n, int):
        raise TypeError("Input must be an integer")

    # Handle small numbers
    if n < 2:
        return False
    if n <= 3:
        return True

    # Exclude multiples of 2 and 3
    if n % 2 == 0 or n % 3 == 0:
        return False

    # 6k ± 1 optimization
    i = 5
    while i * i <= n:
        if n % i == 0 or n % (i + 2) == 0:
            return False
        i += 6

    return True

    
"""SELF-DEBUGGING PROMPT USED:

Write a Python function `is_prime(n: int) -> bool` that returns True if n is a prime
number and False otherwise.
After writing the function, test it with at least five examples (including edge cases
like 0, 1, and negative numbers). If the results are wrong, correct the function.

"""

def is_prime_3(n: int) -> bool:
    """Return True if n is prime, False otherwise."""
    if n <= 1:  # handles negatives, 0, and 1
        return False
    elif n <= 3:  # handles 2 and 3
        return True
    elif n % 2 == 0 or n % 3 == 0:  # eliminates evens
        return False

    i = 5
    while i * i <= n:
        if n % i == 0 or n % (i + 2) == 0:
            return False
        i += 6
    return True

    
# Sonnet 4.5 / Self-Debugging
def is_prime_4(n: int) -> bool:
    """Return True if n is prime, False otherwise."""
    # Handle invalid input types
    if not isinstance(n, int):
        raise TypeError("Input must be an integer")

    # Handle edge cases
    if n <= 1:
        return False

    # 2 is the only even prime number
    if n == 2:
        return True

    # All other even numbers are not prime
    if n % 2 == 0:
        return False

    # Check odd divisors up to sqrt(n)
    i = 3
    while i * i <= n:
        if n % i == 0:
            return False
        i += 2

    return True


"""## 3. Compute the factorial of a non-negative integer.

COT PROMPT USED:

You are an expert Python programmer. Think step by step and explain your reasoning.
Write a Python function factorial(n: int) -> int that returns the factorial of a non-negative integer n.
"""

# GPT-5 / CoT
def factorial(n: int) -> int:
    if n < 0:
        raise ValueError("Factorial is not defined for negative integers.")
    result = 1
    for i in range(2, n + 1):
        result *= i
    return result

# Sonnet 4.5 / CoT
def factorial_2(n: int) -> int:

    if n < 0:
        raise ValueError("Factorial is not defined for negative numbers")
    if n == 0 or n == 1:
        return 1
    result = 1
    for i in range(2, n + 1):
        result *= i

    return result

"""SELF-DEBUGGING PROMPT USED:

Write a Python function factorial(n: int) -> int that returns the factorial of a non-negative integer n.
After writing the function, test it with at least five examples (including edge cases like 0, 1,
and larger values such as 10). If the results are wrong, correct the function.

"""

# GPT-5 / Self-Debugging
def factorial_3(n: int) -> int:
    if n < 0:
        raise ValueError("Factorial is not defined for negative numbers.")
    result = 1
    for i in range(2, n + 1):
        result *= i
    return result

# Test cases
print(f"factorial(0) = {factorial(0)}")   # Expected: 1
print(f"factorial(1) = {factorial(1)}")   # Expected: 1
print(f"factorial(5) = {factorial(5)}")   # Expected: 120
print(f"factorial(7) = {factorial(7)}")   # Expected: 5040
print(f"factorial(10) = {factorial(10)}") # Expected: 3628800

# Sonnet 4.5 / Self-Debugging
def factorial_4(n: int) -> int:

    if n < 0:
        raise ValueError("Factorial is not defined for negative numbers")

    if n == 0 or n == 1:
        return 1

    result = 1
    for i in range(2, n + 1):
        result *= i

    return result


# Test cases
print("Testing factorial function:")
print("-" * 40)

# Test 1: Edge case - factorial of 0
test1 = factorial_4(0)
print(f"factorial(0) = {test1}")
print(f"Expected: 1, Correct: {test1 == 1}")
print()

# Test 2: Edge case - factorial of 1
test2 = factorial_4(1)
print(f"factorial(1) = {test2}")
print(f"Expected: 1, Correct: {test2 == 1}")
print()

# Test 3: Small number - factorial of 5
test3 = factorial_4(5)
print(f"factorial(5) = {test3}")
print(f"Expected: 120, Correct: {test3 == 120}")
print()

# Test 4: Larger number - factorial of 10
test4 = factorial_4(10)
print(f"factorial(10) = {test4}")
print(f"Expected: 3628800, Correct: {test4 == 3628800}")
print()

# Test 5: Another test - factorial of 7
test5 = factorial_4(7)
print(f"factorial(7) = {test5}")
print(f"Expected: 5040, Correct: {test5 == 5040}")
print()

# Test 6: Error case - negative number
print("Testing with negative number:")
try:
    factorial_4(-1)
    print("ERROR: Should have raised ValueError")
except ValueError as e:
    print(f"Correctly raised ValueError: {e}")
print()

print("-" * 40)
print("All tests passed!" if all([
    test1 == 1,
    test2 == 1,
    test3 == 120,
    test4 == 3628800,
    test5 == 5040
]) else "Some tests failed!")

"""## 4. Reverse a given string.

COT PROMPT USED:

You are an expert Python programmer. Think step by step and explain your reasoning.
Write a Python function reverse_string(s: str) -> str that returns the reverse of the input string s.
"""

# GPT-5 / CoT
def reverse_string(s: str) -> str:
    return s[::-1]

# Sonnet 4.5 / CoT
def reverse_string_2(s: str) -> str:
    return s[::-1]

"""SELF-DEBUGGING PROMPT USED:

Write a Python function reverse_string(s: str) -> str that returns the reverse of the input string s.
After writing the function, test it with at least five examples (including edge cases like
an empty string, a single character, and strings with spaces). If the results are wrong, correct the function.

"""

# GPT-5 / Self-Debugging
def reverse_string_3(s: str) -> str:
    return s[::-1]
# Test cases
print(reverse_string(""))           # Edge case: empty string -> Expected output: ""
print(reverse_string("a"))          # Edge case: single character -> Expected output: "a"
print(reverse_string("hello"))      # Normal case -> Expected output: "olleh"
print(reverse_string("racecar"))  # String with leading/trailing spaces -> Expected: " racecar "
print(reverse_string("123 456"))    # String with space in between -> Expected: "654 321"

# Sonnet 4.5 / Self-Debugging
def reverse_string_4(s: str) -> str:
    return s[::-1]


# Test cases
def test_reverse_string():
    """Test the reverse_string function with various inputs."""

    # Test 1: Empty string (edge case)
    test1 = ""
    result1 = reverse_string(test1)
    print(f"Test 1 - Empty string:")
    print(f"  Input: '{test1}'")
    print(f"  Output: '{result1}'")
    print(f"  Expected: ''")
    print(f"  Pass: {result1 == ''}\n")

    # Test 2: Single character (edge case)
    test2 = "a"
    result2 = reverse_string(test2)
    print(f"Test 2 - Single character:")
    print(f"  Input: '{test2}'")
    print(f"  Output: '{result2}'")
    print(f"  Expected: 'a'")
    print(f"  Pass: {result2 == 'a'}\n")

    # Test 3: Simple word
    test3 = "hello"
    result3 = reverse_string(test3)
    print(f"Test 3 - Simple word:")
    print(f"  Input: '{test3}'")
    print(f"  Output: '{result3}'")
    print(f"  Expected: 'olleh'")
    print(f"  Pass: {result3 == 'olleh'}\n")

    # Test 4: String with spaces
    test4 = "hello world"
    result4 = reverse_string(test4)
    print(f"Test 4 - String with spaces:")
    print(f"  Input: '{test4}'")
    print(f"  Output: '{result4}'")
    print(f"  Expected: 'dlrow olleh'")
    print(f"  Pass: {result4 == 'dlrow olleh'}\n")

    # Test 5: Palindrome
    test5 = "racecar"
    result5 = reverse_string(test5)
    print(f"Test 5 - Palindrome:")
    print(f"  Input: '{test5}'")
    print(f"  Output: '{result5}'")
    print(f"  Expected: 'racecar'")
    print(f"  Pass: {result5 == 'racecar'}\n")

    # Test 6: String with special characters
    test6 = "Hello, World!"
    result6 = reverse_string(test6)
    print(f"Test 6 - String with special characters:")
    print(f"  Input: '{test6}'")
    print(f"  Output: '{result6}'")
    print(f"  Expected: '!dlroW ,olleH'")
    print(f"  Pass: {result6 == '!dlroW ,olleH'}\n")


# Run the tests
if __name__ == "__main__":
    test_reverse_string()

"""## 5. Find the maximum element in a list of integers.

COT PROMPT USED:

You are an expert Python programmer. Think step by step and explain your reasoning.
Write a Python function find_max(nums: list[int]) -> int that returns the maximum element in the list nums.
"""

# GPT-5 / CoT
def find_max(nums: list[int]) -> int:
    max_val = 0
    for num in nums:
        if num > max_val:
            max_val = num
    return max_val

# Failing test case
nums = [-10, -5, -30]

find_max(nums)

"""As seen above, this code fails for the above test case of [-10, -5, -20]."""

# CORRECT CODE: GPT-5 / CoT
def find_max(nums: list[int]) -> int:
    """
    Returns the maximum value in a list of integers.
    Raises a ValueError if the list is empty.
    """

    # Edge case: empty list
    if not nums:
        raise ValueError("Empty list has no maximum")

    # Initialize with first element
    max_val = nums[0]

    # Iterate through rest of the list
    for num in nums[1:]:
        if num > max_val:
            max_val = num

    return max_val

# Sonnet 4.5 / CoT
def find_max(nums: list[int]) -> int:
    max_val = 0

    for num in nums:
        if num > max_val:
            max_val = num

    return max_val

# Test cases
print("Test 1 - Positive numbers:", find_max([1, 5, 3, 9, 2]))
print("Test 2 - Mixed numbers:", find_max([-5, 3, -1, 7]))
print("Test 3 - All negative:", find_max([-5, -2, -8, -1]))

# The failing test case
failing_case = [-5, -2, -8, -1]
result = find_max(failing_case)
print(f"\nFailing test case: {failing_case}")
print(f"Expected: -1")
print(f"Got: {result}")
print(f"Test passed: {result == -1}")

"""Similarly, even in this code, the function fails for an array of negative numbers."""

#CORRECT CODE: Sonnet 4.5 / CoT
def find_max(nums: list[int]) -> int:
    max_val = nums[0]  # Initialize with the first element

    for num in nums[1:]:  # Start from second element
        if num > max_val:
            max_val = num

    return max_val


# Test cases
print("Test 1 - Positive numbers:", find_max([1, 5, 3, 9, 2]))  # Returns: 9
print("Test 2 - Mixed numbers:", find_max([-5, 3, -1, 7]))      # Returns: 7
print("Test 3 - All negative:", find_max([-5, -2, -8, -1]))     # Returns: -1
print("Test 4 - Single element:", find_max([42]))                # Returns: 42
print("Test 5 - All same:", find_max([5, 5, 5, 5]))             # Returns: 5

# The previously failing test case now works
failing_case = [-5, -2, -8, -1]
result = find_max(failing_case)
print(f"\nPreviously failing test case: {failing_case}")
print(f"Expected: -1")
print(f"Got: {result}")
print(f"Test passed: {result == -1}")

"""SELF DEBUGGING PROMPT USED:

Write a Python function find_max(nums: list[int]) -> int that returns the maximum element in the list nums.
After writing the function, test it with at least five examples (including edge cases like an empty list,
a list with one element, and a list of negative numbers). If the results are wrong, correct the function.

"""

# GPT-5 / Self Debugging
def find_max(nums: list[int]) -> int:
    if not nums:
        raise ValueError("The list is empty.")

    max_val = nums[0]
    for num in nums[1:]:
        if num > max_val:
            max_val = num
    return max_val

# Test case 1: Normal list
print(find_max([3, 1, 7, 2, 5]))  # Expected output: 7

# Test case 2: List with one element
print(find_max([42]))  # Expected output: 42

# Test case 3: List with all negative numbers
print(find_max([-10, -3, -50, -1]))  # Expected output: -1

# Test case 4: List with all identical elements
print(find_max([4, 4, 4, 4]))  # Expected output: 4

# Test case 5: Empty list (should raise ValueError)
try:
    print(find_max([]))
except ValueError as e:
    print(f"Error: {e}")  # Expected: Error: The list is empty.

# Sonnet 4.5 / Self Debugging
def find_max(nums: list[int]) -> int:
    if not nums:
        raise ValueError("Cannot find max of an empty list")

    max_val = nums[0]
    for num in nums:
        if num > max_val:
            max_val = num
    return max_val


# Test cases
def test_find_max():
    print("Testing find_max function...\n")

    # Test 1: Empty list (edge case)
    print("Test 1: Empty list")
    try:
        result = find_max([])
        print(f"Result: {result}")
    except ValueError as e:
        print(f"Caught expected error: {e}")
    print()

    # Test 2: Single element (edge case)
    print("Test 2: Single element [5]")
    result = find_max([5])
    print(f"Result: {result}")
    print(f"Expected: 5")
    print(f"Pass: {result == 5}")
    print()

    # Test 3: All negative numbers (edge case)
    print("Test 3: All negative numbers [-10, -3, -7, -1, -20]")
    result = find_max([-10, -3, -7, -1, -20])
    print(f"Result: {result}")
    print(f"Expected: -1")
    print(f"Pass: {result == -1}")
    print()

    # Test 4: Mix of positive and negative numbers
    print("Test 4: Mix of positive and negative [3, -5, 7, 2, -1, 9, 4]")
    result = find_max([3, -5, 7, 2, -1, 9, 4])
    print(f"Result: {result}")
    print(f"Expected: 9")
    print(f"Pass: {result == 9}")
    print()

    # Test 5: Maximum at the beginning
    print("Test 5: Maximum at beginning [100, 50, 25, 10]")
    result = find_max([100, 50, 25, 10])
    print(f"Result: {result}")
    print(f"Expected: 100")
    print(f"Pass: {result == 100}")
    print()

    # Test 6: All same values
    print("Test 6: All same values [5, 5, 5, 5]")
    result = find_max([5, 5, 5, 5])
    print(f"Result: {result}")
    print(f"Expected: 5")
    print(f"Pass: {result == 5}")
    print()


# Run the tests
if __name__ == "__main__":
    test_find_max()

"""## 6. Check whether two strings are anagrams.

COT PROMPT USED:

You are an expert Python programmer. Think step by step and explain your reasoning.
Write a Python function are_anagrams(s1: str, s2: str) -> bool that returns True if the two input strings
are anagrams of each other, and False otherwise.
"""

# GPT-5 / COT

def are_anagrams(s1: str, s2: str) -> bool:
    if not isinstance(s1, str) or not isinstance(s2, str):
        raise TypeError("Inputs must be strings")

    s1 = s1.replace(" ", "").lower()
    s2 = s2.replace(" ", "").lower()
    return sorted(s1) == sorted(s2)

# Sonnet 4.5 / COT

def are_anagrams_2(s1: str, s2: str) -> bool:

    # Convert to lowercase to make comparison case-insensitive
    s1_lower = s1.lower()
    s2_lower = s2.lower()

    # Sort both strings and compare
    # If they're anagrams, sorted versions will be identical
    return sorted(s1_lower) == sorted(s2_lower)

"""SELF DEBUGGING PROMPT USED:

Write a Python function are_anagrams(s1: str, s2: str) -> bool that returns True if the two input strings
are anagrams of each other, and False otherwise.
After writing the function, test it with at least five examples (including edge cases such as empty strings,
different lengths, and uppercase vs lowercase strings). If the results are wrong, correct the function.

"""

# GPT-5 / SELF DEBUGGING

def are_anagrams_3(s1: str, s2: str) -> bool:
    # Normalize both strings: remove spaces and make lowercase
    s1 = s1.replace(" ", "").lower()
    s2 = s2.replace(" ", "").lower()

    # If lengths differ, they can’t be anagrams
    if len(s1) != len(s2):
        return False

    # Sort both strings and compare
    return sorted(s1) == sorted(s2)

# 1. Basic anagram
print(are_anagrams_3("listen", "silent"))

# 2. With spaces and capitalization
print(are_anagrams_3("Dormitory", "Dirty room"))

# 3. Different lengths
print(are_anagrams_3("hello", "hell"))

# 4. Not anagrams but same length
print(are_anagrams_3("test", "tess"))

# 5. Edge case: empty strings
print(are_anagrams_3("", ""))

# Sonnet 4.5 / SELF DEBUGGING

def are_anagrams_4(s1: str, s2: str) -> bool:

    # Convert both strings to lowercase to handle case-insensitive comparison
    s1_lower = s1.lower()
    s2_lower = s2.lower()

    # If lengths are different, they cannot be anagrams
    if len(s1_lower) != len(s2_lower):
        return False

    # Sort both strings and compare
    return sorted(s1_lower) == sorted(s2_lower)


# Test cases
print("Testing are_anagrams function:\n")

# Test 1: Basic anagrams
test1 = are_anagrams_4("listen", "silent")
print(f"Test 1 - are_anagrams('listen', 'silent'): {test1}")
print(f"Expected: True\n")

# Test 2: Not anagrams
test2 = are_anagrams_4("hello", "world")
print(f"Test 2 - are_anagrams('hello', 'world'): {test2}")
print(f"Expected: False\n")

# Test 3: Empty strings
test3 = are_anagrams_4("", "")
print(f"Test 3 - are_anagrams('', ''): {test3}")
print(f"Expected: True\n")

# Test 4: Different lengths
test4 = are_anagrams_4("abc", "abcd")
print(f"Test 4 - are_anagrams('abc', 'abcd'): {test4}")
print(f"Expected: False\n")

# Test 5: Case insensitive (uppercase vs lowercase)
test5 = are_anagrams("Listen", "Silent")
print(f"Test 5 - are_anagrams('Listen', 'Silent'): {test5}")
print(f"Expected: True\n")

# Test 6: Mixed case with same letters
test6 = are_anagrams_4("Dormitory", "Dirty Room")
print(f"Test 6 - are_anagrams('Dormitory', 'Dirty Room'): {test6}")
print(f"Expected: False (contains space, different characters)\n")

# Test 7: Single character strings
test7 = are_anagrams_4("a", "a")
print(f"Test 7 - are_anagrams('a', 'a'): {test7}")
print(f"Expected: True\n")

# Test 8: Repeated characters
test8 = are_anagrams_4("aabbcc", "abcabc")
print(f"Test 8 - are_anagrams('aabbcc', 'abcabc'): {test8}")
print(f"Expected: True\n")

# Summary
print("\n" + "="*50)
print("RESULTS SUMMARY:")
print("="*50)
all_tests = [
    (test1, True, "Basic anagrams"),
    (test2, False, "Not anagrams"),
    (test3, True, "Empty strings"),
    (test4, False, "Different lengths"),
    (test5, True, "Case insensitive"),
    (test6, False, "With spaces"),
    (test7, True, "Single character"),
    (test8, True, "Repeated characters")
]

all_passed = True
for i, (result, expected, description) in enumerate(all_tests, 1):
    status = "✓ PASS" if result == expected else "✗ FAIL"
    print(f"Test {i} ({description}): {status}")
    if result != expected:
        all_passed = False

print("="*50)
if all_passed:
    print("All tests passed! ✓")
else:
    print("Some tests failed! ✗")

"""## 7. Count the number of vowels in a string.

COT PROMPT USED:

You are an expert Python programmer. Think step by step and explain your reasoning.
Write a Python function count_vowels(s: str) -> int that returns the number of vowels in the input string s.
"""

# GPT-5 / COT
def count_vowels(s: str) -> int:
    # Convert to lowercase to make the check case-insensitive
    s = s.lower()

    # Define vowels
    vowels = {'a', 'e', 'i', 'o', 'u'}

    # Initialize counter
    count = 0

    # Iterate through each character
    for char in s:
        if char in vowels:
            count += 1

    return count

# Sonnet 4.5 / COT
def count_vowels(s: str) -> int:

    vowels = "aeiouAEIOU"
    count = 0

    for char in s:
        if char in vowels:
            count += 1

    return count

"""SELF DEBUGGING PROMPT USED:

Write a Python function count_vowels(s: str) -> int that returns the number of vowels in the input string s.
After writing the function, test it with at least five examples (including edge cases like an empty string,
a string with no vowels, and a string with uppercase vowels). If the results are wrong, correct the function.

"""

# GPT-5 / SELF DEBUGGING

def count_vowels(s: str) -> int:
    """Return the number of vowels in the input string s."""
    vowels = "aeiouAEIOU"
    count = 0
    for ch in s:
        if ch in vowels:
            count += 1
    return count


# ---- Testing ----
test_cases = [
    "",                       # empty string
    "rhythm",                 # no vowels
    "HELLO",                  # uppercase vowels
    "Hello World",            # mixed case
    "aeiouAEIOUxyz",          # all vowels + extras
]

for t in test_cases:
    print(f"Input: {t!r} → Vowel Count: {count_vowels(t)}")

# Sonnet 4.5 / SELF DEBUGGING

def count_vowels(s: str) -> int:
    """
    Count the number of vowels in a string.

    Args:
        s: Input string

    Returns:
        Number of vowels (a, e, i, o, u) in the string (case-insensitive)
    """
    vowels = "aeiouAEIOU"
    return sum(1 for char in s if char in vowels)


# Test cases
print("Testing count_vowels function:")
print("-" * 50)

# Test 1: Normal string with mixed case
test1 = "Hello World"
result1 = count_vowels(test1)
print(f"Test 1: '{test1}' -> {result1} vowels")
print(f"Expected: 3 (e, o, o) ✓" if result1 == 3 else f"Expected: 3")

# Test 2: Empty string
test2 = ""
result2 = count_vowels(test2)
print(f"\nTest 2: '{test2}' -> {result2} vowels")
print(f"Expected: 0 ✓" if result2 == 0 else f"Expected: 0")

# Test 3: String with no vowels
test3 = "rhythm"
result3 = count_vowels(test3)
print(f"\nTest 3: '{test3}' -> {result3} vowels")
print(f"Expected: 0 ✓" if result3 == 0 else f"Expected: 0")

# Test 4: String with all uppercase vowels
test4 = "AEIOU"
result4 = count_vowels(test4)
print(f"\nTest 4: '{test4}' -> {result4} vowels")
print(f"Expected: 5 ✓" if result4 == 5 else f"Expected: 5")

# Test 5: String with only vowels (mixed case)
test5 = "aEiOu"
result5 = count_vowels(test5)
print(f"\nTest 5: '{test5}' -> {result5} vowels")
print(f"Expected: 5 ✓" if result5 == 5 else f"Expected: 5")

# Test 6: String with special characters and numbers
test6 = "Python3.11!"
result6 = count_vowels(test6)
print(f"\nTest 6: '{test6}' -> {result6} vowels")
print(f"Expected: 1 (o) ✓" if result6 == 1 else f"Expected: 1")

# Test 7: String with repeated vowels
test7 = "aaaaEEEEiiiiOOOOuuuu"
result7 = count_vowels(test7)
print(f"\nTest 7: '{test7}' -> {result7} vowels")
print(f"Expected: 20 ✓" if result7 == 20 else f"Expected: 20")

print("\n" + "=" * 50)
print("All tests passed! ✓")

"""## 8. Compute the GCD of two integers.

COT PROMPT USED:

You are an expert Python programmer. Think step by step and explain your reasoning.
Write a Python function gcd(a: int, b: int) -> int that returns the greatest common divisor (GCD) of a and b.
"""

# GPT-5 / COT
def gcd_wrong(a: int, b: int) -> int:
    while b != 0:
        a = b
        b = a % b
    return a
print(gcd_wrong(20, 8))

"""As seen above, the output is wrong. This happens because it overwrites a before using it in a % b, causing incorrect results or division by zero.

CORRECT PROMPT USED:

You are an expert Python programmer. Think step by step and explain your reasoning.
Write a Python function gcd(a: int, b: int) -> int that correctly returns the greatest common divisor (GCD) of two integers and rightly store the values of a and b so avoid division by 0 error using the Euclidean algorithm.
"""

# CORRECT CODE:

def gcd(a: int, b: int) -> int:
    # Handle undefined case
    if a == 0 and b == 0:
        raise ValueError("gcd(0, 0) is undefined")

    # Use absolute values to support negatives
    a, b = abs(a), abs(b)
    
    # Standard Euclidean algorithm
    while b != 0:
        a, b = b, a % b
    return a

# Sonnet 4.5 / COT

def gcd_2(a: int, b: int) -> int:

    # Handle negative numbers by taking absolute values
    a, b = abs(a), abs(b)

    # Euclid's algorithm
    while b != 0:
        a, b = b, a % b

    return a

# GPT-5 / SELF DEBUGGING PROMPT USED:
def gcd_3(a: int, b: int) -> int:
    """Return the greatest common divisor (GCD) of a and b using Euclid's algorithm."""
    while b != 0:
        a, b = b, a % b
    return abs(a)  # GCD should always be non-negative

# Test cases
print(gcd_3(48, 18))   # common divisor 6
print(gcd_3(0, 5))     # one number is 0 → 5
print(gcd_3(7, 7))     # both equal → 7
print(gcd_3(13, 17))   # primes → 1
print(gcd_3(270, 192)) # larger numbers → 6

# Sonnet 4.5 / SELF DEBUGGING PROMPT USED:
def gcd_4(a: int, b: int) -> int:
    """
    Returns the greatest common divisor of a and b using the Euclidean algorithm.

    Args:
        a: First integer
        b: Second integer

    Returns:
        The greatest common divisor of a and b
    """
    # Convert to absolute values to handle negative numbers
    a, b = abs(a), abs(b)

    # Euclidean algorithm
    while b != 0:
        a, b = b, a % b

    return a


# Test cases
print("Testing GCD function:")
print("-" * 50)

# Test 1: Regular case
result1 = gcd_4(48, 18)
print(f"Test 1: gcd(48, 18) = {result1}")
print(f"Expected: 6, Correct: {result1 == 6}")
print()

# Test 2: One number is 0
result2 = gcd_4(15, 0)
print(f"Test 2: gcd(15, 0) = {result2}")
print(f"Expected: 15, Correct: {result2 == 15}")
print()

# Test 3: Both numbers are equal
result3 = gcd_4(42, 42)
print(f"Test 3: gcd(42, 42) = {result3}")
print(f"Expected: 42, Correct: {result3 == 42}")
print()

# Test 4: Prime numbers (coprime)
result4 = gcd_4(17, 19)
print(f"Test 4: gcd(17, 19) = {result4}")
print(f"Expected: 1, Correct: {result4 == 1}")
print()

# Test 5: One number divides the other
result5 = gcd_4(100, 25)
print(f"Test 5: gcd(100, 25) = {result5}")
print(f"Expected: 25, Correct: {result5 == 25}")
print()

# Test 6: Both numbers are 0
result6 = gcd_4(0, 0)
print(f"Test 6: gcd(0, 0) = {result6}")
print(f"Expected: 0, Correct: {result6 == 0}")
print()

# Test 7: Negative numbers
result7 = gcd_4(-48, 18)
print(f"Test 7: gcd(-48, 18) = {result7}")
print(f"Expected: 6, Correct: {result7 == 6}")
print()

print("-" * 50)
print("All tests passed!" if all([
    result1 == 6,
    result2 == 15,
    result3 == 42,
    result4 == 1,
    result5 == 25,
    result6 == 0,
    result7 == 6
]) else "Some tests failed!")

"""## 9. Return "Even" if a number is even, "Odd" otherwise.

COT PROMPT USED:

You are an expert Python programmer. Think step by step and explain your reasoning.
Write a Python function even_or_odd(n: int) -> str that returns "Even" if n is even, and "Odd" otherwise.
"""

# GPT-5 / COT
def even_or_odd(n: int) -> str:
    if n % 2 == 0:
        return "Even"
    else:
        return "Odd"

# Sonnet 4.5 / COT
def even_or_odd_2(n: int) -> str:
    """
    Determines if a number is even or odd.

    Args:
        n: An integer to check

    Returns:
        "Even" if n is divisible by 2, "Odd" otherwise
    """
    if n % 2 == 0:
        return "Even"
    else:
        return "Odd"

"""SELF DEBUGGING PROMPT USED:

Write a Python function even_or_odd(n: int) -> str that returns "Even" if n is even, and "Odd" otherwise.
After writing the function, test it with at least five examples (including edge cases like 0,
negative numbers, and large integers). If the results are wrong, correct the function.

"""

# GPT-5 / Self Debugging
def even_or_odd_3(n: int) -> str:
    if n % 2 == 0:
        return "Even"
    else:
        return "Odd"

# Test examples
print(even_or_odd_3(0))          # Edge case: 0 is Even
print(even_or_odd_3(7))          # Odd number
print(even_or_odd_3(-4))         # Negative Even number
print(even_or_odd_3(-9))         # Negative Odd number
print(even_or_odd_3(1234567890)) # Large Even number

def even_or_odd_4(n: int) -> str:
    """
    Returns "Even" if n is even, "Odd" if n is odd.

    Args:
        n: An integer to check

    Returns:
        "Even" or "Odd"
    """
    if n % 2 == 0:
        return "Even"
    else:
        return "Odd"


# Test cases
test_cases = [
    (0, "Even"),           # Edge case: zero
    (1, "Odd"),            # Small positive odd
    (2, "Even"),           # Small positive even
    (-5, "Odd"),           # Negative odd
    (-10, "Even"),         # Negative even
    (1000000, "Even"),     # Large even number
    (999999, "Odd"),       # Large odd number
]

print("Testing even_or_odd function:")
print("-" * 50)

all_passed = True
for num, expected in test_cases:
    result = even_or_odd_4(num)
    status = "✓" if result == expected else "✗"
    if result != expected:
        all_passed = False
    print(f"{status} even_or_odd({num:>7}) = {result:>4} (expected: {expected})")

print("-" * 50)
if all_passed:
    print("All tests passed! ✓")
else:
    print("Some tests failed! ✗")

"""## 10. Given an integer, return its square.

COT PROMPT USED:

You are an expert Python programmer. Think step by step and explain your reasoning.
Write a Python function square(n: int) -> int that returns the square of the integer n.
"""

# GPT-5 / COT
def square(n: int) -> int:
    """Return the square of the integer n."""
    return n * n

# Sonnet 4.5 / COT
def square_2(n: int) -> int:
    """
    Returns the square of an integer.

    Args:
        n: An integer to be squared

    Returns:
        The square of n (n²)

    Examples:
        >>> square(5)
        25
        >>> square(-3)
        9
        >>> square(0)
        0
    """
    return n ** 2

"""SELF DEBUGGING PROMPT USED:

Write a Python function square(n: int) -> int that returns the square of the integer n.
After writing the function, test it with at least five examples (including edge cases like 0,
negative numbers, and large integers). If the results are wrong, correct the function.

"""

# GPT-5 / SELF DEBUGGING
def square_3(n: int) -> int:
    """Return the square of the integer n."""
    return n * n
# Test cases
test_values = [0, 1, -3, 10, 1000000]

for val in test_values:
    print(f"square({val}) = {square(val)}")

# SONNET 4.5 / SELF DEBUGGING
def square_4(n: int) -> int:
    """
    Returns the square of an integer n.

    Args:
        n: An integer to be squared

    Returns:
        The square of n (n * n)
    """
    return n * n


# Test cases
print("Testing square function:")
print("-" * 40)

# Test 1: Positive integer
test1 = square_4(5)
print(f"square(5) = {test1}")
print(f"Expected: 25, Result: {'✓' if test1 == 25 else '✗'}")

# Test 2: Zero (edge case)
test2 = square_4(0)
print(f"\nsquare(0) = {test2}")
print(f"Expected: 0, Result: {'✓' if test2 == 0 else '✗'}")

# Test 3: Negative integer
test3 = square_4(-7)
print(f"\nsquare(-7) = {test3}")
print(f"Expected: 49, Result: {'✓' if test3 == 49 else '✗'}")

# Test 4: Small negative integer
test4 = square_4(-1)
print(f"\nsquare(-1) = {test4}")
print(f"Expected: 1, Result: {'✓' if test4 == 1 else '✗'}")

# Test 5: Large integer
test5 = square_4(1000)
print(f"\nsquare(1000) = {test5}")
print(f"Expected: 1000000, Result: {'✓' if test5 == 1000000 else '✗'}")

# Test 6: Very large integer (additional edge case)
test6 = square_4(999999)
print(f"\nsquare(999999) = {test6}")
print(f"Expected: 999998000001, Result: {'✓' if test6 == 999998000001 else '✗'}")

print("\n" + "-" * 40)
print("All tests passed! ✓")
